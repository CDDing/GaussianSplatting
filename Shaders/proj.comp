#version 450

// ─── 상수 ───
layout(local_size_x = 256) in;

// ─── 카메라 UBO ───
layout(set = 0, binding = 0) uniform CameraUBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    vec4 camPos;        // xyz = position
    uvec2 screenSize;   // width, height
    float fovX;
    float fovY;
    float zNear;
    float zFar;
} camera;

// ─── 입력: SOA 레이아웃 ───
layout(set = 0, binding = 1) readonly buffer PositionBuffer {
    float positions[];  // N×3 (x, y, z per gaussian)
};

layout(set = 0, binding = 2) readonly buffer SHBuffer {
    float shCoeffs[];   // f_dc: N×3
};

layout(set = 0, binding = 3) readonly buffer OpacityBuffer {
    float opacities[];  // N×1
};

layout(set = 0, binding = 4) readonly buffer ScaleBuffer {
    float scales[];     // N×3 (log-scale)
};

layout(set = 0, binding = 5) readonly buffer RotationBuffer {
    float rotations[];  // N×4 (w, x, y, z)
};

// ─── 출력: 2D 프로젝션 결과 ───
struct Gaussian2D {
    vec2 mean2D;        // 스크린 좌표
    float depth;        // 정렬용
    float radius;       // 타일 컬링용 바운딩 반지름
    vec3 conic;         // 2D 공분산 역행렬 (대칭이라 3개면 충분: a, b, c)
    float opacity;      // sigmoid(raw_opacity)
    uint tileCount;     // 이 가우시안이 터치하는 타일 수
};

layout(set = 0, binding = 6) writeonly buffer Gaussian2DBuffer {
    Gaussian2D projected[];
};

// ─── 가시성 플래그 (컬링된 가우시안 마킹) ───
layout(set = 0, binding = 7) buffer VisibilityBuffer {
    uint visible[];     // 0 = culled, 1 = visible
};

// ─── 타일 카운터 (후속 정렬 패스용) ───
layout(set = 0, binding = 8) buffer TileCountBuffer {
    uint tileCounts[];  // per-gaussian tile overlap count
};

layout(push_constant) uniform PushConstants {
    uint gaussianCount;
    uint tileWidth;     // ceil(screenWidth / TILE_SIZE)
    uint tileHeight;
};

#define TILE_SIZE 16

// ─── 쿼터니언 → 회전행렬 ───
mat3 quatToRotMat(vec4 q) {
    float w = q.x, x = q.y, y = q.z, z = q.w;
    return mat3(
    1.0 - 2.0*(y*y + z*z),  2.0*(x*y - w*z),        2.0*(x*z + w*y),
    2.0*(x*y + w*z),         1.0 - 2.0*(x*x + z*z),  2.0*(y*z - w*x),
    2.0*(x*z - w*y),         2.0*(y*z + w*x),         1.0 - 2.0*(x*x + y*y)
    );
}

// ─── 3D 공분산 → 2D 공분산 프로젝션 (EWA Splatting) ───
vec3 computeConic(vec3 scale, vec4 rot, vec3 worldPos) {
    // 1) 3D 공분산: Σ = R * S * S^T * R^T
    mat3 R = quatToRotMat(rot);
    vec3 s = exp(scale); // log-scale → actual scale
    mat3 S = mat3(
    s.x, 0.0, 0.0,
    0.0, s.y, 0.0,
    0.0, 0.0, s.z
    );
    mat3 M = R * S;
    mat3 Sigma = M * transpose(M);

    // 2) 야코비안: 월드→카메라→NDC 변환의 편미분
    vec4 camSpace = camera.viewMatrix * vec4(worldPos, 1.0);
    float tx = camSpace.x / camSpace.z;
    float ty = camSpace.y / camSpace.z;
    float tz = camSpace.z;

    float limx = 1.3 * camera.fovX;
    float limy = 1.3 * camera.fovY;
    tx = clamp(tx, -limx, limx);
    ty = clamp(ty, -limy, limy);

    float focalX = camera.screenSize.x / (2.0 * camera.fovX);
    float focalY = camera.screenSize.y / (2.0 * camera.fovY);

    mat3 J = mat3(
    focalX / tz,     0.0,              0.0,
    0.0,             focalY / tz,      0.0,
    -(focalX * tx) / tz, -(focalY * ty) / tz, 0.0
    );

    mat3 W = mat3(camera.viewMatrix); // 상위 3x3
    mat3 T = J * W;

    // 3) 2D 공분산: Σ' = T * Σ * T^T  (+ low-pass filter)
    mat3 cov3 = T * Sigma * transpose(T);
    // 수치 안정성을 위한 low-pass filter
    cov3[0][0] += 0.3;
    cov3[1][1] += 0.3;

    // 2x2 상위 블록만 사용
    float a = cov3[0][0];
    float b = cov3[0][1];
    float c = cov3[1][1];

    // 역행렬 (대칭 2x2)
    float det = a * c - b * b;
    if (det < 1e-6) det = 1e-6;
    float invDet = 1.0 / det;

    return vec3(c * invDet, -b * invDet, a * invDet); // conic
}

// ─── 바운딩 반지름 계산 (고유값 기반) ───
float computeRadius(vec3 conic) {
    // conic = inverse(cov2D), 다시 cov2D의 고유값에서 반지름 추출
    float det = 1.0 / (conic.x * conic.z - conic.y * conic.y);
    float a = conic.z * det;  // cov2D[0][0]
    float b = -conic.y * det;
    float c = conic.x * det;  // cov2D[1][1]

    float mid = 0.5 * (a + c);
    float diff = 0.5 * sqrt(max((a - c) * (a - c) + 4.0 * b * b, 0.0));
    float lambda = mid + diff; // 최대 고유값

    return ceil(3.0 * sqrt(lambda)); // 3-sigma
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= gaussianCount) return;

    // ─── SOA에서 데이터 읽기 ───
    vec3 position = vec3(positions[idx*3], positions[idx*3+1], positions[idx*3+2]);
    float opa     = opacities[idx];
    vec3 scl      = vec3(scales[idx*3], scales[idx*3+1], scales[idx*3+2]);
    vec4 rot      = vec4(rotations[idx*4], rotations[idx*4+1], rotations[idx*4+2], rotations[idx*4+3]);

    // ─── View-space 변환 & frustum culling ───
    vec4 viewPos = camera.viewMatrix * vec4(position, 1.0);
    if (viewPos.z < camera.zNear || viewPos.z > camera.zFar) {
        visible[idx] = 0;
        tileCounts[idx] = 0;
        return;
    }

    // ─── NDC 프로젝션 ───
    vec4 clipPos = camera.projMatrix * viewPos;
    vec2 ndc = clipPos.xy / clipPos.w;

    // 큰 범위 밖이면 컬링
    if (any(greaterThan(abs(ndc), vec2(1.3)))) {
        visible[idx] = 0;
        tileCounts[idx] = 0;
        return;
    }

    // 스크린 좌표
    vec2 mean2D = (ndc * 0.5 + 0.5) * vec2(camera.screenSize);

    // ─── 2D 공분산 & conic ───
    vec3 conic = computeConic(scl, rot, position);
    float radius = computeRadius(conic);
    float opacity = 1.0 / (1.0 + exp(-opa)); // sigmoid

    // ─── 타일 오버랩 계산 ───
    uvec2 tileMin = uvec2(
    clamp(uint((mean2D.x - radius) / TILE_SIZE), 0u, tileWidth - 1u),
    clamp(uint((mean2D.y - radius) / TILE_SIZE), 0u, tileHeight - 1u)
    );
    uvec2 tileMax = uvec2(
    clamp(uint((mean2D.x + radius) / TILE_SIZE), 0u, tileWidth - 1u),
    clamp(uint((mean2D.y + radius) / TILE_SIZE), 0u, tileHeight - 1u)
    );
    uint tileCount = (tileMax.x - tileMin.x + 1u) * (tileMax.y - tileMin.y + 1u);

    // ─── 결과 기록 ───
    visible[idx] = 1;
    tileCounts[idx] = tileCount;

    projected[idx].mean2D = mean2D;
    projected[idx].depth = viewPos.z;
    projected[idx].radius = radius;
    projected[idx].conic = conic;
    projected[idx].opacity = opacity;
    projected[idx].tileCount = tileCount;
}
